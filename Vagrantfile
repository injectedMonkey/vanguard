# -*- mode: ruby -*-
# vi: set ft=ruby :

dir = File.dirname(File.expand_path(__FILE__))

require "yaml"
require "json"
require "#{dir}/vagrant/ruby/deep_merge"
require "#{dir}/vagrant/ruby/inventory_path"

# install required plugins if necessary
if ARGV[0] == 'up'
    # add required plugins here
    required_plugins = %w( vagrant-bindfs )
    missing_plugins = []
    required_plugins.each do |plugin|
        missing_plugins.push(plugin) unless Vagrant.has_plugin? plugin
    end

    if ! missing_plugins.empty?
        install_these = missing_plugins.join(' ')
        puts "Found missing plugins: #{install_these}.  Installing..."
        exec "vagrant plugin install #{install_these}; vagrant up"
    end
end

host_groups = {}
host_vars = {}

config = YAML.load_file "#{dir}/config.yml"
machines = config["machines"]

Vagrant.configure("2") do |vagrant|
  # Iterate over multiple machines if configured
  (1..machines.count).each do |machine_id|
    settings = machines[machines.keys[machine_id -1]]
    # These values are the default options
      vagrant.bindfs.default_options = {
        force_user:   'vagrant',
        force_group:  'vagrant',
        perms:        'u=rwX:g=rD:o=rD',
      }

    if machines.count == 1
      vagrant.vm.synced_folder "/Users/imnky/projects/node-scraper", "/home/vagrant/nfs", type: :nfs
      #vagrant.vm.synced_folder "/Users/imnky/projects/symfony-test-project", "/vagrant-nfs", type: :nfs

      vagrant.bindfs.bind_folder "/home/vagrant/nfs", "/var/www/node-scraper"
      #vagrant.bindfs.bind_folder "/vagrant-nfs", "/var/www/project", o:"nonempty", after: :provision
    end

    # Setting up base vagrant for vm
    # @todo generic provisioning for all providers
    vagrant.vm.provider :parallels do |parallels|
      parallels.update_guest_tools = false
      parallels.memory = settings["memory"]
      parallels.cpus = settings["cpus"]
    end

    # Setting up the guest system
    vagrant.vm.define settings["hostname"] do |machine|
      machine.vm.box = settings["box"]
      machine.vm.hostname = settings["hostname"]
      machine.vm.network "private_network", ip: settings["ip"]

      if settings.has_key?("forwarding")
        settings["forwarding"].each do |name, port|
          machine.vm.network "forwarded_port", guest: port["guest"], host: port["host"]
        end
      end
    end

    # Create host_vars
    if settings.has_key?("host_vars")
      hashes = {}

      settings["host_vars"].each do |section, values|
        hash = {
          "#{section}" => "'#{values.to_json}'"
        }
        hashes = hashes.deep_merge(hash)
      end

      host_vars[settings["hostname"]] = hashes
    end

    # Create host_groups for ansible inventory
    if settings.has_key?("host_groups")
      settings["host_groups"].each do |group|
        hash = {
          "#{group}" => [ settings["hostname"] ]
        }
        host_groups = host_groups.deep_merge(hash)
      end
    end

    # provision new guest system(s)
    if machine_id == machines.count
      vagrant.vm.provision :ansible do |ansible|
        ansible.limit = "all"
        ansible.playbook = "./ansible/#{config["playbook"]}"
        ansible.groups = host_groups
        ansible.host_vars = host_vars
        ansible.verbose = config["output"]

        ansible.extra_vars = {
          "php" => {
            "version" => 5.6
          }
        }
      end

      if config["run_local"]
        # Run local provisioning to populate inventory generated by vagrant
        vagrant.vm.provision "ansible_local" do |ansible|
          ansible.playbook = "./ansible/#{config["playbook_local"]}"
          ansible.inventory_path = getInventoryPath("#{dir}/ansible.cfg")
          ansible.install = true
          ansible.limit = "localhost"
          ansible.verbose = config["output"]
        end
      end
    end

  end # each
end # vagranture
